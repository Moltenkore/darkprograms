chat = {}
X, Y = term.getSize()
Version = 1.32
autoupdate = true
BottomText = "Message: "
KeyCount = 0
user = ""
Header = "Welcome to darkchat "..Version.."!"
function findPeripheral(Perihp) 
  for _,s in ipairs(rs.getSides()) do
    if peripheral.isPresent(s) and peripheral.getType(s) == Perihp then
      return s
    end
  end
  return false
end
function gitUpdate(ProgramName, Filename, ProgramVersion)
  if http then
    local getGit = http.get("https://github.com/darkrising/darkprograms/raw/darkprograms/darksecurity/programVersions")
    local getGit = getGit.readAll()
    NVersion = textutils.unserialize(getGit)
    if NVersion[ProgramName].Version > ProgramVersion then
      getGit = http.get(NVersion[ProgramName].GitURL)
      getGit = getGit.readAll()
      local file = fs.open(Filename, "w")
      file.write(getGit)
      file.close()
      return true
    end
  else
    return false
  end
end
function split(str, pattern) -- Splits string by pattern, returns table
  local t = { }
  local fpat = "(.-)" .. pattern
  local last_end = 1
  local s, e, cap = str:find(fpat, 1)
  while s do
    if s ~= 1 or cap ~= "" then
      table.insert(t,cap)
    end
    last_end = e+1
    s, e, cap = str:find(fpat, last_end)
  end
  if last_end <= #str then
    cap = str:sub(last_end)
    table.insert(t, cap)
  end
  return t
end
function cWrite(Text, bgcolor, tecolor, solid)
  if term.isColor() == true then
    term.setBackgroundColor(colors[bgcolor])
    term.setTextColor(colors[tecolor])
    if solid then
      term.write(string.rep(" ", #Text))
    else
      term.write(Text)
    end
  else
    term.write(Text)
  end
end
function bgReset()
  if term.isColor() == true then
    term.setTextColor(colors.white)
    term.setBackgroundColor(colors.black)
  end
end
function rSend(message, special, hidden)
  local messaget = {}
  messaget.user = user
  messaget.message = message
  messaget.darkchat = true
  messaget.id = os.getComputerID()
  if special then messaget.special = true end
  messaget = textutils.serialize(messaget)
  modem.transmit(channelN,channelN,messaget)
  if not hidden then
    if special then
      table.insert(chat, "yellow#* "..user.." "..message)
    else
      table.insert(chat, "white#"..user..": "..message)
    end
  end
end
function rReceive()
  local darkchat = false
  repeat
    _,_,C,rC,M,D = os.pullEvent("modem_message")
    M = textutils.unserialize(M)
    if type(M) == "table" and M.darkchat then
      darkchat = true
    end
  until darkchat == true
  return M
end
function clears()
  for i = 1, Y - 2 do
    term.setCursorPos(1,i)
    term.write(string.rep(" ", X))
  end
  return true
end
function getChat()
  while true do
    m = rReceive()
    if m.id ~= os.getComputerID() and m.user ~= user and m.message then
      if m.special then
        table.insert(chat, "yellow#* ".. m.user .. " " .. m.message)
      else
        table.insert(chat, "white#" .. m.user ..": ".. m.message)
      end
    end
    draw()
  end
end
function draw()
  bgReset() clears()
  if #chat == Y - 1 then table.remove(chat, 1) end  
  for i = 1, #chat do
    chatN = split(chat[i], "#")
    term.setCursorPos(1,i)
    cWrite(chatN[2],"black",chatN[1])
  end
  term.setCursorPos(1, Y - 1)
  cWrite(string.rep("-", X), "blue","blue", true)
  term.setTextColor(colors.white)
  local Text = "<User: "..user.."> <Channel: "..channelN..">"
  term.setCursorPos(X/2 - #Text/2, Y - 1)
  write(Text)
  bgReset()
  term.setCursorPos(#BottomText + KeyCount + 1, Y)
  return true
end
function sendChat()
  while true do
    term.setCursorPos(1, Y)
    term.write(BottomText)
    message = read()
    if string.sub(message,1,1) == "/" then
      commandS = string.sub(message,2,#message)
      commandS = split(commandS, " ")
      if comD[commandS[1]] then
        comD[commandS[1]](commandS)
      else
        table.insert(chat, "red#Unknown Command")
        draw()
      end
    elseif message == "" then
      draw()
    elseif message then
      rSend(message)
      draw()
    end
  end
end
function keyListen()
  while true do
    Type, KEY = os.pullEvent("key")
    if KEY == 28 then 
      KeyCount = 0
    elseif KEY == 14 then
      if KeyCount ~= 0 then
        KeyCount = KeyCount - 1
      end
    elseif KEY then
      if KEY ~= 54 then
        KeyCount = KeyCount + 1
      end
    end
  end
end
function startUp()
  term.clear() term.setCursorPos(1,1)
  if autoupdate == true then
  print("Checking for updates...")
    if gitUpdate("chat", shell.getRunningProgram(), Version) == true then
      print("Download new version, restarting...")
      sleep(1.5)
      os.reboot()
    else
      print("You're running the latest version")
      sleep(1)
    end
  end
  Side = findPeripheral("modem")
  if not Side then
    print("no modem.")
    return exit
  end
  modem = peripheral.wrap(Side)
  term.clear() term.setCursorPos(1,1)
  cWrite(string.rep("-", X), "blue","blue", true) bgReset()
  term.setCursorPos(X/2 - string.len(Header)/2,2)
  print(Header)
  cWrite(string.rep("-", X), "blue","blue", true) bgReset()
end
function privateMode()
  user = config.user
  channelN = config.channel
end
function publicMode()
  repeat
    write("Nickname: ")
    user = read()
    if user == "" then
      print("\nInvalid Name")
    end
  until user ~= ""
  print("\nDefault channel is 10")
  write("Channel: ")
  channelN = read()
  if not tonumber(channelN) then
    channelN = "10"
  end
end
comD = {
  ["exit"] = function()
    rSend("has quit.", true)
    os.reboot()  
  end,
  ["me"] = function(Words)
    local StringRe = ""
    for i = 2, #Words do
      StringRe = StringRe..Words[i].." "
    end
    rSend(StringRe, true)
  end,
  ["channel"] = function(Channels)
    local SetChan = Channels[2]
    if not tonumber(SetChan) then
      table.insert(chat, "red#Error: Must be a number.")
      draw()
    else
      rSend("has changed channel.", true)
      channelN = tonumber(SetChan)
      modem.closeAll()
      modem.open(channelN)
      rSend("has entered the channel!", true, true)
    end
  end,
}
--[[
28: enter
14: backspace
]]--
term.clear() term.setCursorPos(1,1)
if fs.exists(".darkChatConf") == true then
  F = fs.open(".darkChatConf", "r")
  Data = F.readAll()
  F.close()
  config = textutils.unserialize(Data)
else
  config = {}
  repeat
    print("Do you want DarkChat private mode?")
    write("y / n : ")
    Qprivate = read()
  until Qprivate == "y" or Qprivate == "n"
  if Qprivate == "y" then
    config.private = true
    write("\nUsername: ")
    config.user = read()
    repeat
      write("Default channel number: ")
      Qchannel = read()
    until tonumber(Qchannel)
    config.channel = tonumber(Qchannel)
  else
    config.private = false
  end
  configString = textutils.serialize(config)
  F = fs.open(".darkChatConf", "w")
  F.write(configString)
  F.close()
  print("Setup Complete!")
  sleep(1)
end
startUp()
if config.private == true then
  privateMode()
else
  publicMode()
end
channelN = tonumber(channelN)
modem.closeAll()
modem.open(channelN)
term.clear()
term.setCursorPos(1,1)
rSend("has joined the chat!", true, true)
parallel.waitForAll(getChat, draw, sendChat, keyListen)