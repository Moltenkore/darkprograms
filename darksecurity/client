--Title: Dark Client
Version = 4.11
--Author: Darkrising (minecraft name djhannz)
--Platform: ComputerCraft Lua Virtual Machine
AutoUpdate = true
x,y = term.getSize()
if fs.exists("dark") == false then -- load darkAPI
  print("Missing DarkAPI")
  sleep(2)
  print("Attempting to download...")
  getGit = http.get("https://github.com/darkrising/darkprograms/raw/darkprograms/darksecurity/dark")
  getGit = getGit.readAll()
  file = fs.open("dark", "w")
  file.write(getGit)
  file.close()
  os.reboot()
else
  os.loadAPI("dark")
end
function rednetSendE(ID, Message)
  if not config.enCode then
    Message = dark.encrypt(Message, 1)
  else
    Message = dark.repCrypt(Message, config.enCode)
  end
  rednet.send(ID, Message)
end
function rednetReceiveE(TimeA)
  local Se,Me,Di = rednet.receive(TimeA)
  if Me then
    if not config.enCode then
      Me = dark.decrypt(Me, 1, true)
    else
      Me = dark.repdeCrypt(Me, config.enCode)
    end
    return Se,Me,Di
  end
end
function header(text, lText, rText)
  dark.printL("-", 1, nil, "blue", "blue")
  dark.printA("|", x, 2, nil, "blue", "blue")
  dark.printA("|", 1, 2, nil, "blue", "blue")
  dark.printC(string.rep(" ", x), 2, nil, "white", "blue")
  if lText then dark.printA(lText, 1, 2, nil, "white", "blue") end
  if rText then dark.printA(rText, x - #rText, 2, nil, "white", "blue") end
  dark.printC(text, 2, nil, "yellow", "blue")
  dark.printL("-", 3, 5, "blue", "blue")
end
function footer()
  dark.printL("-", y, nil, "blue", "blue")
  dark.printA("by darkrising", x-13, y, nil, "yellow", "blue")
end
function keycard_mainProgram()
  while true do
    event, eventinfo, extrainfo = os.pullEvent("disk")
    com2 = {}
    com2.computerid = os.getComputerID()
    com2.area = tonumber(config.securityLevel)
    
    if disk.hasData(eventinfo) == true then
      com2.diskQuery = disk.getID(eventinfo) 
      SendString = textutils.serialize(com2)
      rednetSendE(config.serverID, SendString)
      
      S, M = rednetReceiveE(2)
      
      if M == "#granted" then
        disk.eject(eventinfo)
        rs.setOutput(config.doorside, true)
        sleep(config.pulseTime)
        rs.setOutput(config.doorside, false)
      end
      disk.eject(eventinfo)
    else
      disk.eject(eventinfo)
    end
  end
end
function userandpassword_mainProgram()
  while true do
    com = {}
    com.computerid = os.getComputerID()
    com.area = tonumber(config.securityLevel)
    
    term.clear() term.setCursorPos(1,1)
    footer()
    header(config.tLabel)
    print("") print("")
    
    write(">  Username: ") 
    status, User = pcall(read)
    com.userQuery = User
    
    write(">  Password: ") 
    status, password = pcall(read, "*")
    com.passQuery = password
    
    SendString = textutils.serialize(com)
    
    if ((User ~= nil) and (password ~= nil)) then
      rednetSendE(config.serverID, SendString)
      ID, MES = rednetReceiveE(2)
      if MES == nil then
      print("\nWrong or no response from server.")
      sleep(2)
      else
        if MES == "#granted" then
          dark.printC("Correct", 5, 5)
          rs.setOutput(config.doorside, true)
          sleep(config.pulseTime)
          rs.setOutput(config.doorside, false)
        end
      end
    end
  end
end

S = dark.findPeripheral("modem")
if S == false then
  print("Please attach Modem") 
  return exit
else
  rednet.open(S)  
end
function stealthUpdate()
  if AutoUpdate == true then 
    if ((dark.gitUpdate("client", shell.getRunningProgram(), Version) == true) or (dark.gitUpdate("dark", "dark", dark.DARKversion) == true)) then
      os.reboot()
    end
  end
end
if fs.exists(".DarkC_conf") == false then
  config = {}
  SideList = rs.getSides()
  
  term.clear()
  term.setCursorPos(1,1)
  header("Dark Client Setup")
  
  print("Computer's id is ".. os.getComputerID())
  
  write("\nPlease type the server / relay id: ")
  config.serverID = tonumber(io.read())
  
  repeat
    write("\nTerminal Security Level: ")
    config.securityLevel = io.read()
  until tonumber(config.securityLevel)
  config.securityLevel = tonumber(config.securityLevel)
  
  repeat
    write("\nRedstone output side: ")
    doorside = io.read()
  until dark.db.search(doorside, SideList) > 0
  config.doorside = doorside
  
  write("\nRedstone pulse time (in seconds): ")
  pulseTime = tonumber(io.read())
  config.pulseTime = pulseTime
  
  write("\nTerminal label: ")
  config.tLabel = io.read()
  
  print("\nWhat type of terminal is this?")
  print("options: 'keycard', 'password' or 'both'")
  repeat
    write(": ")
    tType = read()
  until ((tType == "keycard") or (tType == "password") or (tType == "both"))
  config.tType = tType
  
  print("\nDo you have an encryption key? (if you added the client's id manually to the server)")
  print("options: y / n")
  repeat
    write(": ")
    encKey = read()
  until (encKey == "y") or (encKey == "n")
  if encKey == "y" then
    repeat
      write("Encryption key: ")
      encKey = read()
    until tonumber(encKey)
  else
    print("\nPlease make sure your server is up and running.")
    print("Please type your server Admin username and password.")
    com = {}
    write("\nUsername: ")
    com.userQuery = read()
    write("Password: ")
    com.passQuery = read("*")    
    com.area = tonumber(config.securityLevel)
    com.computerid = os.getComputerID()
    com.super = true
    com.addMe = true
    message = textutils.serialize(com)
    rednetSendE(config.serverID, message)
    s,m,d = rednetReceiveE(2)
    if s then
      print("Success!")
      config.enCode = tonumber(m)
    else
      print("failed, please add manually.")
      repeat
        write("Encryption key: ")
        encKey = read()
      until tonumber(encKey)
    end    
  end
  
  dark.db.save(".DarkC_conf", config)
  
  print("\nsetup complete!")
  sleep(1)
end

config = dark.db.load(".DarkC_conf")

if config.tType == "keycard" then
  parallel.waitForAll(keycard_mainProgram, stealthUpdate)
elseif config.tType == "password" then
  parallel.waitForAll(userandpassword_mainProgram, stealthUpdate)
elseif config.tType == "both" then
  print("hi")
  parallel.waitForAll(keycard_mainProgram, userandpassword_mainProgram, stealthUpdate)
end